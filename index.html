<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destiny.gg Vestaboard Dono Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #1f2128; 
            color: #e5e7eb;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .pixel-cell {
            width: 30px;
            height: 30px;
            cursor: pointer;
            border: 1px solid #5a5a60;
            transition: transform 0.05s ease-out, border-color 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 1px #1f2937;
        }

        .pixel-cell:hover {
            transform: scale(1.1);
            border-color: #a3a3a3;
        }
        
        .pixel-cell.typing-cursor {
            border: 3px solid #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
        }

        .sequential-space-highlight {
            border: 3px solid #ef4444 !important;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.7);
        }

        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            margin: 4px;
            border: 3px solid transparent;
            transition: all 0.15s ease-in-out;
            display: flex; 
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }

        .color-option.selected {
            transform: scale(1.15);
            box-shadow: 0 0 0 3px #3b3e47, 0 0 0 6px #e5e7eb; 
        }
        
        .mode-selector {
            background-color: transparent;
            border: 3px solid #6b7280;
            color: #fff;
        }

        .text-mode-option {
            font-size: 20px;
        }
        
        .dot-mode-option {
            font-size: 24px;
            line-height: 1; 
        }

        .mode-selector.active {
            transform: scale(1.15);
            border-color: #22d3ee;
            box-shadow: 0 0 0 3px #3b3e47, 0 0 0 6px #22d3ee;
        }

        #pixelGrid {
            display: grid;
            grid-template-columns: repeat(22, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: fit-content;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            background-color: #31343a; 
        }

        #outputString {
            resize: none;
            height: 100px;
            word-break: break-all;
            background-color: #000;
            border: 1px solid #4a4a50;
        }
    </style>
</head>
<body>

<div class="p-6 max-w-4xl w-full bg-[#2c2e36] rounded-xl shadow-2xl">
    <h1 class="text-3xl font-bold mb-6 text-center text-cyan-400">Destiny.gg Vestaboard Dono Generator</h1>
    
    <div class="mb-8 p-4 bg-[#3b3e47] rounded-lg">
        <h2 class="text-xl font-semibold mb-3">Mode/Color Selector</h2>
        
        <div id="paletteContainer" class="flex flex-wrap justify-center items-center">
            
            <div class="flex items-center mr-4 pr-4 border-r border-gray-600">
                <div id="textModeButton" onclick="toggleTextMode()" 
                     class="color-option mode-selector text-mode-option transition duration-150" 
                     title="Text Mode: Click to type directly onto the grid (black background).">
                    A
                </div>
                
                <div id="dotModeButton" onclick="toggleDotMode()" 
                     class="color-option mode-selector dot-mode-option transition duration-150" 
                     title="Dot Mode: Click to draw black tiles using '.' character.">
                    .
                </div>
            </div>

            <div id="colorPalette" class="flex flex-wrap justify-center">
            </div>
            
        </div>
        
        <p id="currentModeDisplay" class="text-center mt-3 text-sm text-gray-400">Current Mode: <span class="font-bold text-white">Color Mode (#000)</span></p>

        <div class="mt-4 pt-3 border-t border-gray-600 flex justify-center">
            <button onclick="fillGrid()" class="w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Fill Grid
            </button>
        </div>
    </div>

    <div class="mb-8 p-4 bg-[#3b3e47] rounded-lg">
        <h2 class="text-xl font-semibold mb-3">Pixel Canvas (22 x 4)</h2>
        <div id="pixelGrid" class="mx-auto">
        </div>
    </div>
    
    <div class="p-4 bg-[#3b3e47] rounded-lg">
        <h2 class="text-xl font-semibold mb-3">Mapped Character String (Vestaboard Output)</h2>
        <textarea id="outputString" class="w-full p-3 rounded-lg text-sm text-cyan-300" readonly></textarea>
        
        <div id="lengthWarning" class="mt-2 text-red-400 text-sm text-center font-semibold" style="display:none;"></div>
        <div id="spaceWarning" class="mt-2 text-red-400 text-sm text-center font-semibold" style="display:none;"></div>

        <div class="flex space-x-2 mt-3">
            <button onclick="copyOutput()" class="w-1/3 bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Copy String
            </button>
            <button onclick="replaceBlackWithDot()" class="w-1/3 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Replace Black with Dot (.)
            </button>
             <button onclick="clearGrid()" class="w-1/3 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Clear All
            </button>
        </div>

        <div class="mt-4 pt-4 border-t border-gray-600">
            <h3 class="text-lg font-semibold mb-2 text-white">Share/Bookmark URL (Compressed)</h3>
            <button onclick="generateShareableURL()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                Generate Compressed URL
            </button>
            <input type="text" id="shareUrlInput" readonly placeholder="Click the button to generate the URL" 
                   class="w-full mt-2 p-2 rounded-lg text-sm bg-gray-700 text-cyan-300 border-none select-all cursor-pointer" 
                   title="Click to copy URL"
                   onclick="this.select(); document.execCommand('copy');">
        </div>
        
        <div id="copyMessage" class="mt-2 text-cyan-400 text-sm text-center opacity-0 transition duration-300">Copied!</div>
    </div>
</div>

<script>
    const GRID_DIMENSIONS = {
        COLS: 22,
        ROWS: 4,
        TOTAL_PIXELS: 88,
        MAX_OUTPUT_LENGTH: 255
    };

    const MODES = {
        DEFAULT_COLOR: '#000',
        DOT_MODE_VALUE: 'DOT_MODE_VALUE'
    };

    const COLOR_MAP = {
        '#f00': '{63}',
        '#f80': '{64}',
        '#ff0': '{65}',
        '#0f0': '{66}',
        '#00f': '{67}',
        '#80f': '{68}',
        '#fff': '{70}',
        '#000': '{71}'
    };
    
    const REVERSE_COLOR_MAP = {
        '{63}': '#f00',
        '{64}': '#f80',
        '{65}': '#ff0',
        '{66}': '#0f0',
        '{67}': '#00f',
        '{68}': '#80f',
        '{70}': '#fff',
        '{71}': '#000'
    };

    const PALETTE_COLORS = Object.keys(COLOR_MAP); 
    const COLOR_NAMES = {
        '#f00': 'Red', '#f80': 'Orange', '#ff0': 'Yellow',
        '#0f0': 'Green', '#00f': 'Blue', '#80f': 'Purple',
        '#fff': 'White', '#000': 'Black',
        [MODES.DOT_MODE_VALUE]: 'Dot/Blank'
    };

    const COLOR_LITERALS = Object.keys(REVERSE_COLOR_MAP);
    const ORDERED_COLOR_LITERALS = ['{71}', '{70}', '{63}', '{64}', '{65}', '{66}', '{67}', '{68}'];
    
    const ALLOWED_CHARS_BASE = [
        ' ', '!', '#', '$', '%', '&', '(', ')', '-', '=', ';', ':', '\'', '"', ',', '.', '?',
        '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        String.fromCharCode(176)
    ];

    const ALLOWED_CHARS_SET = new Set(ALLOWED_CHARS_BASE);
    ALLOWED_CHARS_BASE.filter(char => char.match(/[A-Z]/)).map(char => char.toLowerCase()).forEach(char => ALLOWED_CHARS_SET.add(char));
    
    const TOKEN_MAPPING = {
        TO_INDEX: {},
        TO_TOKEN: []
    };
    let mappingIndex = 0;

    ORDERED_COLOR_LITERALS.forEach(token => {
        TOKEN_MAPPING.TO_INDEX[token] = mappingIndex;
        TOKEN_MAPPING.TO_TOKEN[mappingIndex] = token;
        mappingIndex++;
    }); 

    ALLOWED_CHARS_BASE.forEach(token => {
        TOKEN_MAPPING.TO_INDEX[token] = mappingIndex;
        TOKEN_MAPPING.TO_TOKEN[mappingIndex] = token;
        mappingIndex++;
    }); 

    let currentColor = MODES.DEFAULT_COLOR;
    let isTextModeActive = false;
    let typingIndex = 0;
    let isRendering = false;
    let isDrawing = false;
    
    const elements = {
        pixelGrid: document.getElementById('pixelGrid'),
        colorPalette: document.getElementById('colorPalette'),
        outputString: document.getElementById('outputString'),
        currentModeDisplay: document.querySelector('#currentModeDisplay span'),
        copyMessage: document.getElementById('copyMessage'),
        lengthWarning: document.getElementById('lengthWarning'),
        spaceWarning: document.getElementById('spaceWarning'),
        textModeButton: document.getElementById('textModeButton'),
        dotModeButton: document.getElementById('dotModeButton'), 
        shareUrlInput: document.getElementById('shareUrlInput')
    };

    function getAllTokens(inputString) {
        const tokens = [];
        let i = 0;

        while (i < inputString.length && tokens.length < GRID_DIMENSIONS.TOTAL_PIXELS) {
            let currentToken = '';
            let tokenLength = 1;

            if (inputString.substring(i, i + 1) === '{' && inputString.length >= i + 4) {
                const potentialLiteral = inputString.substring(i, i + 4);
                if (COLOR_LITERALS.includes(potentialLiteral)) {
                    currentToken = potentialLiteral;
                    tokenLength = 4;
                }
            }

            if (!currentToken) {
                currentToken = inputString[i];
                tokenLength = 1;
            }
            
            if (currentToken.length === 1 && !TOKEN_MAPPING.TO_INDEX[currentToken]) {
                currentToken = COLOR_MAP[MODES.DEFAULT_COLOR];
            }
            
            tokens.push(currentToken);
            i += tokenLength;
        }
        
        while (tokens.length < GRID_DIMENSIONS.TOTAL_PIXELS) {
            tokens.push(COLOR_MAP[MODES.DEFAULT_COLOR]);
        }
        
        return tokens.slice(0, GRID_DIMENSIONS.TOTAL_PIXELS);
    }

    function generateCompressedString(tokens) {
        let binaryString = '';
        
        tokens.forEach(token => {
            let index = TOKEN_MAPPING.TO_INDEX[token];
            if (index === undefined) {
                index = TOKEN_MAPPING.TO_INDEX[COLOR_MAP[MODES.DEFAULT_COLOR]];
            }
            
            const sixBit = index.toString(2).padStart(6, '0');
            binaryString += sixBit;
        });

        while (binaryString.length % 8 !== 0) {
            binaryString += '0';
        }

        const bytes = [];
        for (let i = 0; i < binaryString.length; i += 8) {
            const byte = binaryString.substring(i, i + 8);
            bytes.push(parseInt(byte, 2));
        }

        const charCodes = bytes.map(byte => String.fromCharCode(byte));
        const base64 = btoa(charCodes.join(''));

        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    function decodeCompressedString(compressed) {
        let base64 = compressed.replace(/-/g, '+').replace(/_/g, '/');
        while (base64.length % 4) {
            base64 += '=';
        }

        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }

        let binaryString = '';
        bytes.forEach(byte => {
            binaryString += byte.toString(2).padStart(8, '0');
        });

        const requiredBits = GRID_DIMENSIONS.TOTAL_PIXELS * 6;
        binaryString = binaryString.substring(0, requiredBits);

        const tokens = [];
        for (let i = 0; i < requiredBits; i += 6) {
            const sixBit = binaryString.substring(i, i + 6);
            const index = parseInt(sixBit, 2);
            
            const token = TOKEN_MAPPING.TO_TOKEN[index];
            if (token) {
                tokens.push(token);
            } else {
                tokens.push(COLOR_MAP[MODES.DEFAULT_COLOR]);
            }
        }
        
        return tokens.join('');
    }
    
    function getTokenCount(inputString) {
        let charIndex = 0;
        let tokenCount = 0;
        
        while (charIndex < inputString.length && tokenCount < GRID_DIMENSIONS.TOTAL_PIXELS) {
            let tokenLength = 1;

            if (inputString.substring(charIndex, charIndex + 1) === '{' && inputString.length >= charIndex + 4) {
                const potentialLiteral = inputString.substring(charIndex, charIndex + 4);
                if (COLOR_LITERALS.includes(potentialLiteral)) {
                    tokenLength = 4;
                }
            }
            
            charIndex += tokenLength;
            tokenCount++;
        }
        return tokenCount;
    }

    function getCharIndexFromPixelIndex(pixelIndex) {
        const inputString = elements.outputString.value;
        let charIndex = 0;
        let tokenCount = 0;
        
        while (charIndex < inputString.length && tokenCount < pixelIndex) {
            let tokenLength = 1;

            if (inputString.substring(charIndex, charIndex + 1) === '{' && inputString.length >= charIndex + 4) {
                const potentialLiteral = inputString.substring(charIndex, charIndex + 4);
                if (COLOR_LITERALS.includes(potentialLiteral)) {
                    tokenLength = 4;
                }
            }
            
            charIndex += tokenLength;
            tokenCount++;
        }
        return charIndex;
    }
    
    function getCleanChar(rawChar) {
        if (!rawChar || rawChar.length !== 1) return null;
        
        let char = rawChar[0];

        if (char >= 'a' && char <= 'z') {
            char = char.toUpperCase();
        }
        
        if (ALLOWED_CHARS_SET.has(char)) {
            return char;
        }
        
        return null;
    }
    
    function updateTypingIndicator() {
        Array.from(elements.pixelGrid.children).forEach(cell => {
            cell.classList.remove('typing-cursor');
        });

        if (isTextModeActive) {
            const currentCell = elements.pixelGrid.children[typingIndex];
            if (currentCell) {
                currentCell.classList.add('typing-cursor');
            }
        }
    }

    function renderGridFromOutput() {
        if (isRendering) return;
        isRendering = true; 

        const inputString = elements.outputString.value; 
        const tokens = getAllTokens(inputString); 
        const actualTokenCount = getTokenCount(inputString);

        const sequentialSpacePixelIndices = [];
        for (let j = 0; j < actualTokenCount; j++) { 
            const token = tokens[j];
            
            if (token === ' ') {
                const prevToken = j > 0 ? tokens[j - 1] : null;
                const nextToken = j < GRID_DIMENSIONS.TOTAL_PIXELS - 1 ? tokens[j + 1] : null;
                
                if ((prevToken === ' ' || nextToken === ' ') && j < actualTokenCount) { 
                    sequentialSpacePixelIndices.push(j);
                }
            }
        }
        
        for (let j = 0; j < GRID_DIMENSIONS.TOTAL_PIXELS; j++) {
            const cell = elements.pixelGrid.children[j];
            
            if (!cell) continue;

            cell.classList.remove('sequential-space-highlight');

            if (j < actualTokenCount) {
                const token = tokens[j]; 
                let color = 'transparent'; 
                
                if (token && token.startsWith('{')) { 
                    color = REVERSE_COLOR_MAP[token] || 'transparent'; 
                    cell.textContent = ''; 
                } else if (token) { 
                    color = 'transparent'; 
                    cell.textContent = token; 
                } else {
                    color = MODES.DEFAULT_COLOR;
                    cell.textContent = '';
                }
                
                cell.style.backgroundColor = color;
                
                if (sequentialSpacePixelIndices.includes(j)) {
                    cell.classList.add('sequential-space-highlight');
                }

            } else {
                cell.style.backgroundColor = 'transparent';
                cell.textContent = '';
            }
        }
        
        const currentLength = inputString.length;
        elements.lengthWarning.style.display = currentLength > GRID_DIMENSIONS.MAX_OUTPUT_LENGTH ? 'block' : 'none';
        elements.lengthWarning.textContent = `WARNING: The output string length (${currentLength} characters) exceeds the ${GRID_DIMENSIONS.MAX_OUTPUT_LENGTH} character limit.`;
        
        const hasSequentialSpaces = inputString.includes('  '); 
        
        elements.spaceWarning.style.display = hasSequentialSpaces ? 'block' : 'none';
        elements.spaceWarning.textContent = "WARNING: Sequential spaces will be truncated into a single space in the donation.";
        
        isRendering = false;
    }

    function updatePixel(index, newContent) {
        if (index < 0 || index >= GRID_DIMENSIONS.TOTAL_PIXELS) return;
        
        const value = elements.outputString.value;
        let newLiteral;

        if (newContent === MODES.DOT_MODE_VALUE) {
            newLiteral = '.';
        } else if (newContent.length === 1 && getCleanChar(newContent) !== null) {
            newLiteral = newContent; 
        } else {
            newLiteral = COLOR_MAP[newContent] || COLOR_MAP[MODES.DEFAULT_COLOR]; 
        }

        const currentTokenCount = getTokenCount(value);
        const startCharIndex = getCharIndexFromPixelIndex(index);

        if (index >= currentTokenCount) {
            const tokensToFill = index - currentTokenCount; 
            
            if (tokensToFill > 0) {
                elements.outputString.value += '.'.repeat(tokensToFill);
            }
            
            elements.outputString.value += newLiteral;

            renderGridFromOutput(); 
            return;
        }

        let existingTokenLength = 1;
        const currentToken = value.substring(startCharIndex, startCharIndex + 4); 

        if (COLOR_LITERALS.includes(currentToken) && currentToken.startsWith('{')) {
            existingTokenLength = 4;
        } else if (value[startCharIndex] !== undefined) {
            existingTokenLength = 1;
        } else {
            existingTokenLength = 0;
        }
        
        const newValue = value.substring(0, startCharIndex) + 
                         newLiteral + 
                         value.substring(startCharIndex + existingTokenLength);

        elements.outputString.value = newValue;
        
        renderGridFromOutput();
    }

    function toggleTextMode() {
        isTextModeActive = !isTextModeActive;
        
        if (isTextModeActive) {
            elements.textModeButton.classList.add('active');
            elements.currentModeDisplay.textContent = 'Text Mode (Direct Typing)';
            
            selectColor(null); 
            elements.dotModeButton.classList.remove('active');

            currentColor = MODES.DEFAULT_COLOR; 
            
        } else {
            elements.textModeButton.classList.remove('active');
            selectColor(MODES.DEFAULT_COLOR);
        }

        updateTypingIndicator();
    }
    
    function toggleDotMode() {
        if (currentColor === MODES.DOT_MODE_VALUE) {
            selectColor(MODES.DEFAULT_COLOR);
            return;
        }
        
        isTextModeActive = false;
        elements.textModeButton.classList.remove('active');
        
        currentColor = MODES.DOT_MODE_VALUE;
        
        elements.currentModeDisplay.textContent = `Color Mode (${COLOR_NAMES[currentColor]})`;
        
        Array.from(elements.colorPalette.children).forEach(el => el.classList.remove('selected'));
        
        elements.dotModeButton.classList.add('active');
        
        updateTypingIndicator();
    }

    function selectColor(color) {
        if (color) {
            currentColor = color;
            elements.currentModeDisplay.textContent = `Color Mode (${color} - ${COLOR_NAMES[color]})`;

            isTextModeActive = false;
            elements.textModeButton.classList.remove('active');
            elements.dotModeButton.classList.remove('active');
        }
        
        Array.from(elements.colorPalette.children).forEach(el => {
            el.classList.remove('selected');
            if (el.dataset.color === currentColor && !isTextModeActive && currentColor !== MODES.DOT_MODE_VALUE) {
                el.classList.add('selected');
            }
        });
        
        if (currentColor === MODES.DOT_MODE_VALUE && !isTextModeActive) {
            elements.dotModeButton.classList.add('active');
        } else {
            elements.dotModeButton.classList.remove('active');
        }
        
        updateTypingIndicator();
    }
    
    function flashMessage(message, isError = false) {
        elements.copyMessage.textContent = message;
        
        elements.copyMessage.classList.remove('opacity-0', 'text-red-400', 'text-cyan-400');
        
        if (isError) {
            elements.copyMessage.classList.add('opacity-100', 'text-red-400');
        } else {
            elements.copyMessage.classList.add('opacity-100', 'text-cyan-400');
        }
        
        setTimeout(() => {
            elements.copyMessage.classList.remove('opacity-100');
            elements.copyMessage.classList.add('opacity-0');
        }, 2500);
    }

    function handleGlobalKeydown(e) {
        if (!isTextModeActive) return;

        if (e.key === 'Backspace') {
            e.preventDefault();
            
            let deletePixelIndex = (typingIndex - 1 + GRID_DIMENSIONS.TOTAL_PIXELS) % GRID_DIMENSIONS.TOTAL_PIXELS;

            const value = elements.outputString.value;
            const startCharIndex = getCharIndexFromPixelIndex(deletePixelIndex);

            if (startCharIndex >= value.length) {
                typingIndex = deletePixelIndex;
                updateTypingIndicator();
                return;
            }
            
            const token = value.substring(startCharIndex, startCharIndex + 4);
            let tokenLength = 1;
            
            if (COLOR_LITERALS.includes(token) && token.startsWith('{')) {
                tokenLength = 4;
            } else if (value[startCharIndex] === undefined) {
                typingIndex = deletePixelIndex;
                updateTypingIndicator();
                return;
            }
            
            elements.outputString.value = value.substring(0, startCharIndex) + 
                                   value.substring(startCharIndex + tokenLength);
            
            typingIndex = deletePixelIndex; 
            
            renderGridFromOutput(); 
            updateTypingIndicator();
            return;
        }

        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            typingIndex = (typingIndex - 1 + GRID_DIMENSIONS.TOTAL_PIXELS) % GRID_DIMENSIONS.TOTAL_PIXELS;
            updateTypingIndicator();
            return;
        }
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            typingIndex = (typingIndex + 1) % GRID_DIMENSIONS.TOTAL_PIXELS;
            updateTypingIndicator();
            return;
        }
        
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            typingIndex = (typingIndex - GRID_DIMENSIONS.COLS + GRID_DIMENSIONS.TOTAL_PIXELS) % GRID_DIMENSIONS.TOTAL_PIXELS;
            updateTypingIndicator();
            return;
        }

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            typingIndex = (typingIndex + GRID_DIMENSIONS.COLS) % GRID_DIMENSIONS.TOTAL_PIXELS;
            updateTypingIndicator();
            return;
        }

        if (e.metaKey || e.ctrlKey || e.altKey || e.key.length > 1) {
            return;
        }

        const cleanedChar = getCleanChar(e.key);

        if (cleanedChar !== null) {
            e.preventDefault();
            
            updatePixel(typingIndex, cleanedChar); 

            typingIndex = (typingIndex + 1) % GRID_DIMENSIONS.TOTAL_PIXELS;
            
            updateTypingIndicator();
        }
    }

    function loadStateFromURL() {
        const params = new URLSearchParams(window.location.search);
        const compressedContent = params.get('c');
        const content = params.get('content');

        if (compressedContent) {
            try {
                elements.outputString.value = decodeCompressedString(compressedContent);
                return true;
            } catch (e) {
                console.error("Failed to decode compressed URL:", e);
            }
        }

        if (content) {
            if (content.length > 0) {
                elements.outputString.value = content;
                return true;
            }
        }
        return false;
    }

    function generateShareableURL() {
        const inputString = elements.outputString.value;
        const tokens = getAllTokens(inputString);
        const compressed = generateCompressedString(tokens);
        const baseUrl = window.location.origin + window.location.pathname;
        const shareUrl = `${baseUrl}?c=${compressed}`;
        
        elements.shareUrlInput.value = shareUrl;

        try {
            elements.shareUrlInput.select(); 
            document.execCommand('copy');
            flashMessage("Compressed URL generated and copied!");
        } catch (e) {
            flashMessage("Compressed URL generated (copy manually).", true);
        }
    }
    
    function clearGrid() {
        elements.outputString.value = "";
        typingIndex = 0;
        isTextModeActive = false;
        selectColor(MODES.DEFAULT_COLOR);
        renderGridFromOutput();
        
        flashMessage("Grid cleared to Empty.");
    }

    function fillGrid() {
        let fillLiteral;
        let colorName;
        
        if (currentColor === MODES.DOT_MODE_VALUE) {
            fillLiteral = '.';
            colorName = COLOR_NAMES[MODES.DOT_MODE_VALUE];
        } else {
            fillLiteral = COLOR_MAP[currentColor];
            colorName = COLOR_NAMES[currentColor];
        }

        elements.outputString.value = fillLiteral.repeat(GRID_DIMENSIONS.TOTAL_PIXELS);

        typingIndex = 0; 
        updateTypingIndicator();
        renderGridFromOutput();

        flashMessage(`Grid filled with ${colorName}.`);
    }

    function createGrid() {
        for (let i = 0; i < GRID_DIMENSIONS.TOTAL_PIXELS; i++) {
            const cell = document.createElement('div');
            cell.classList.add('pixel-cell');
            cell.dataset.index = i;

            cell.addEventListener('click', () => {
                const index = parseInt(cell.dataset.index);
                
                if (isTextModeActive) {
                    typingIndex = index;
                    updateTypingIndicator();
                } else {
                    updatePixel(index, currentColor);
                }
            });
            
            cell.addEventListener('mousedown', (e) => {
                if (e.buttons === 1 && !isTextModeActive) {
                    isDrawing = true;
                    updatePixel(i, currentColor);
                }
            });
            
            cell.addEventListener('mouseover', () => {
                if (isDrawing) {
                    updatePixel(i, currentColor);
                }
            });
            
            elements.pixelGrid.appendChild(cell);
        }
    }

    function createPalette() {
        PALETTE_COLORS.forEach(color => {
            const option = document.createElement('div');
            option.classList.add('color-option');
            
            if (color === MODES.DEFAULT_COLOR) {
                 option.classList.add('mode-selector'); 
            }
            
            option.style.backgroundColor = color;
            option.dataset.color = color;

            option.addEventListener('click', () => selectColor(color));

            option.title = `${COLOR_NAMES[color]} | Maps to ${COLOR_MAP[color]}`;

            elements.colorPalette.appendChild(option);
        });
        
        selectColor(MODES.DEFAULT_COLOR);
    }
    
    function copyOutput() {
        try {
            elements.outputString.select();
            document.execCommand('copy');
            flashMessage("String copied to clipboard!");
            
        } catch (err) {
            console.error('Copy Error:', err);
            flashMessage("Copy failed. Try selecting and copying manually.", true);
        }
    }

    function replaceBlackWithDot() {
        const originalString = elements.outputString.value; 
        const blackLiteral = COLOR_MAP[MODES.DEFAULT_COLOR];
        const replacedString = originalString.replaceAll(blackLiteral, '.');

        elements.outputString.value = replacedString;
        renderGridFromOutput();
        flashMessage("Black pixels replaced with dots (.).");
    }

    document.addEventListener('DOMContentLoaded', () => {
        createGrid();
        createPalette();
        
        const loadedFromURL = loadStateFromURL();
        
        if (!loadedFromURL) {
            elements.outputString.value = "";
        }
        
        renderGridFromOutput(); 

        document.addEventListener('keydown', handleGlobalKeydown);
        
        document.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        updateTypingIndicator();
    });

</script>
</body>
</html>
